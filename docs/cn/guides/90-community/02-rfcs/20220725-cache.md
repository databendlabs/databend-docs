---
title: 缓存
description: Databend 查询的缓存机制
---

- RFC PR: [datafuselabs/databend#6799](https://github.com/datafuselabs/databend/pull/6799)
- 跟踪问题: [datafuselabs/databend#6786](https://github.com/datafuselabs/databend/issues/6786)

## 概述

为 Databend 查询添加缓存支持，以便用户可以从我们的缓存服务中加载热数据，而不是再次从后端存储服务中读取。

## 动机

Databend 的设计基于存储和计算的分离：

![](/img/rfc/20220725-cache/architecture.svg)

因此，Databend 将支持不同的云存储服务作为其后端，如 AWS s3、azure blob 和 google cloud storage。这样做的好处是我们可以获得非常高的吞吐量带宽，但缺点是我们的单个请求延迟增加。

添加缓存层将改善整体延迟并减少不必要的请求，从而降低成本。

Databend 曾经有一个基于本地磁盘的缓存
在 [common-cache](https://github.com/datafuselabs/databend/tree/cd5124c4fbf53e8992f820c7b0a0fbc6442876e6/common/cache)。
这个实现使用 databend-query 的本地路径来缓存块。

## 指南级解释

引入缓存后，Databend 存储层将由以下部分组成：

![](/img/rfc/20220725-cache/cache.png)

查询将维护三个 OpenDAL 操作符：

- `持久化操作符`：直接从/向存储服务读取和写入持久化数据。
- `缓存操作符`：通过透明缓存读取和写入数据。
- `临时操作符`：从/向临时存储读取和写入临时数据，临时存储仅存储具有 TTL 的数据。

我们在这里提到的存储、缓存和临时服务都是 OpenDAL 支持的服务。区别在于：

- `持久化服务`：所有数据将被持久化，直到用户删除它们。
- `缓存服务`：后端可以有自己的 GC 或后台自动驱逐逻辑，这意味着缓存服务是非持久化的，即易失的。
- `临时服务`：后端将配置 TTL，并及时删除旧数据。

查询永远不应尝试将持久化数据写入 `缓存操作符` 或 `临时操作符`。

### 对于终端用户

用户可以为缓存或存储临时数据指定不同的缓存服务。例如，他们可以将数据缓存到本地文件系统（与当前行为相同）：

```toml
[cache]
type = "fs"

[cache.fs]
data_path = "/var/cache/databend/"
```

或者他们可以将数据缓存到分布式缓存服务，如 `opencache`：

```toml
[cache]
type = "opencache"

[cache.opencache]
endpoints = ["192.168.1.2"]
```

临时数据可以跨整个集群共享，因此用户必须使用共享存储服务，如 `redis` 或 `s3`，而不是本地文件系统或内存：

```toml
[temporary]
type = "s3"

[temporary.s3]
bucket = "temporary-data"
endpoint = "http://127.0.0.1:9900"
```

### 对于开发者

如前所述，开发者现在有三种 `操作符` 来处理不同的工作负载：

- `持久化`：直接读取和写入数据，不带缓存逻辑，类似于 `O_DIRECT`。
- `缓存`：通过透明缓存读取和写入数据，类似于内核的页面缓存。
- `临时`：将临时数据读取和写入缓存服务，类似于 Linux 的 `tmpfs`，旧数据可以及时删除。

## 参考级解释

### 缓存操作符

`缓存操作符` 将实现为 [Apache OpenDAL 层](https://docs.rs/opendal/0.11.2/opendal/trait.Layer.html)：

```rust
#[derive(Clone, Default, Debug)]
pub struct CacheLayer {
    // 持久化数据的操作符（通过 `storage` 配置）
    persist: Operator,
    // 缓存数据的操作符（通过 `cache` 配置）
    cache: Operator,
    // KVApi 客户端
    kv: Arc<dyn KVApi>,
}

impl Layer for CacheLayer {}
impl Accessor for CacheLayer {}
```

databend-query 将初始化缓存层以及持久化操作符：

```rust
pub fn get_cache_operator(&self) -> Operator {
    self.get_storage_operator().layer(CacheLayer::new())
}
```

![](/img/rfc/20220725-cache/cache-operator.png)

`缓存层` 的详细实现将不在本 RFC 中讨论。

### 临时操作符

临时操作符将连接到共享存储服务，该服务为整个集群提供相同的视图。查询可以将临时中间结果写入这里与其他节点共享。

大部分工作应在服务端完成。我们不会在本 RFC 中讨论这一点。

## 缺点

无。

## 基本原理和替代方案

无。

## 先前技术

无。

## 未解决问题

无。

## 未来可能性

### OpenCache

[OpenCache](https://github.com/datafuselabs/opencache) 是 Databend 社区正在进行的工作，旨在构建分布式缓存服务。一旦其 API 稳定，Apache OpenDAL 将实现对 `OpenCache` 的原生支持。之后，用户可以部署和使用 OpenCache 作为 `缓存` 存储。