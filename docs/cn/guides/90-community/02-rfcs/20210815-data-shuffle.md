---
title: 分布式查询与数据重排
description: 分布式查询和数据重排的RFC
---

## 概述

分布式查询是分布式数据库的必要功能。
本文档旨在解释分布式查询及其数据流设计。

## 本地查询

让我们看看在单个数据库节点上正常查询是如何运行的。

```text
'        +------+       +------------+      +---------+
'        |      |  AST  |            | Plan |         |
' SQL--->|Parser+------>|Plan Builder+----->|Optimizer|
'        |      |       |            |      |         |
'        +------+       +------------+      +---+-----+
'                                               | Plan
'                                               v
'                 +----------+            +-----------+
'                 |          |  Processor |           |
'     Data <------+DataStream|<-----------+Interpreter|
'                 |          |            |           |
'                 +----------+            +-----------+
```

### 解析器和抽象语法树（AST）

Databend使用第三方SQL解析器及其抽象语法树（AST）。
更多信息，请参见：https://github.com/ballista-compute/sqlparser-rs

### 计划构建器和查询计划

查询计划（或查询执行计划）是用于在Databend中访问数据的一系列步骤。它由计划构建器从AST构建。我们也使用树来描述它（类似于AST）。但它与AST有一些差异：

- 查询计划是可序列化和反序列化的。
- 查询计划在语法上是安全的，我们不必担心它。
- 查询计划用于描述计算和数据依赖关系，与语法优先级无关
- 我们可以使用`EXPLAIN SELECT ...`来展示它

```text
EXPLAIN SELECT number % 3 AS key, SUM(number) AS value FROM numbers(1000) WHERE number > 10 AND number < 990 GROUP BY key ORDER BY key ASC LIMIT 10;
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| explain                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Limit: 10
  Projection: (number % 3) as key:UInt8, SUM(number) as value:UInt64
    Sort: (number % 3):UInt8,
      AggregatorFinal: groupBy=[[(number % 3)]], aggr=[[SUM(number)]]
        AggregatorPartial: groupBy=[[(number % 3)]], aggr=[[SUM(number)]]
          Expression: (number % 3):UInt8, number:UInt64 (Before GroupBy)
            Filter: ((number > 10) AND (number < 990))
              ReadDataSource: scan partitions: [8], scan schema: [number:UInt64], statistics: [read_rows: 1000, read_bytes: 8000] |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
```

### 优化器和查询计划

对于一个查询，尤其是复杂的查询，可以使用不同的计划组合、顺序和结构来获取数据。每种不同的方式都会得到不同的处理时间。因此，我们需要在最短时间内找到一种合理的计划组合方式，这就是优化器所做的。

### 解释器和处理器

解释器将优化后的计划构建成可执行的数据流。我们通过拉取数据流中的数据来获取SQL的结果。SQL中每个操作符的计算逻辑对应一个处理器，例如FilterPlan -> FilterProcessor，ProjectionPlan -> ProjectionProcessor

## 分布式查询

在集群模式下，我们可能需要处理一些与单机模式不同的问题。

- 在分布式模式下，要查询的表总是分布在不同的节点上
- 对于某些场景，分布式处理总是高效的，例如带有键的GROUP BY，JOIN
- 对于某些场景，我们无法进行分布式处理，例如LIMIT，不带键的GROUP BY
- 为了确保快速计算，我们需要协调计算和数据的位置。

让我们看看在数据库集群上正常查询是如何运行的。

```text
'                                              +------+       +------------+      +------------------+
'                                              |      |  AST  |            | Plan |    Optimizer     |
'                                       SQL--->|Parser+------>|Plan Builder+----->|                  |
'                                              |      |       |            |      | ScatterOptimizer |
'                                              +------+       +------------+      +--------+---------+
'                                                                                          |
'                                        +--------------+                                  |
'                                        |              |                                  |
'                                     +--+ FlightStream | <------+                         |  Plan
'                                     |  |              |        |                         |
'                                     |  +--------------+        |                         |
'                                     |                          |                         |
'                                     |                          |                         |
'                                     |                          |    Flight RPC           v
'        +----------+    Processor    |  +--------------+        |                  +----------------+
'        |          | RemoteProcessor |  |              |        |     do_action    |  Interpreter   |
' Data<--+DataStream|<----------------+--+ FlightStream | <------+------------------+                |
'        |          |                 |  |              |        |                  | PlanRescheduler|
'        +----------+                 |  +--------------+        |                  +----------------+
'                                     |                          |
'                                     |                          |
'                                     |                          |
'                                     |                          |
'                                     |  +--------------+        |
'                                     |  |              |        |
'                                     +--+ FlightStream | <------+
'                                        |              |
'                                        +--------------+
```

### 分散优化器和阶段计划

在Databend中，我们使用分散优化器来决定查询的分布式计算。换句话说，分布式查询是对单机查询的一种优化。

在分散优化器中，我们遍历查询的所有计划并重写感兴趣的计划`（重写为StagePlan { kind:StageKind, input:Self }）`，其中input是被重写的计划，kind是一个枚举（Normal：数据再次重排，Expansive：数据从一个节点扩散到多个节点，Convergent：数据从多个节点聚合到一个节点）

### 计划调度器和远程处理器

在集群模式下，我们提取分散优化器优化后的计划中的所有StagePlans，并根据kind将它们发送到集群中的相应节点。

例如：

```text
EXPLAIN SELECT argMin(user, salary)  FROM (SELECT sum(number) AS salary, number%3 AS user FROM numbers_local(1000000000) GROUP BY user);
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| explain                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Projection: argMin(user, salary):UInt64   <-- 在本地节点执行
  AggregatorFinal: groupBy=[[]], aggr=[[argMin(user, salary)]]
    RedistributeStage[expr: 0]    <-- 在集群的所有节点执行
      AggregatorPartial: groupBy=[[]], aggr=[[argMin(user, salary)]]
        Projection: sum(number) as salary:UInt64, (number % 3) as user:UInt8
  AggregatorFinal: groupBy=[[(number % 3)]], aggr=[[sum(number)]]
    RedistributeStage[expr: sipHash(_group_by_key)]   <-- 在集群的所有节点执行
      AggregatorPartial: groupBy=[[(number % 3)]], aggr=[[sum(number)]]
        Expression: (number % 3):UInt8, number:UInt64 (Before GroupBy)
          RedistributeStage[expr: blockNumber()]    <-- 在本地节点执行
            ReadDataSource: scan partitions: [8], scan schema: [number:UInt64], statistics: [read_rows: 1000000000, read_bytes: 8000000000] |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
```

### Flight API 数据流

我们需要以某种方式获取发送至其他节点执行的计划的结果。FuseData 使用第三方库 arrow-flight。更多信息：[https://github.com/apache/arrow-rs/tree/master/arrow-flight]