---
title: JSON 优化
description: Databend 查询的 JSON 优化
---

- RFC PR: [datafuselabs/databend#6995](https://github.com/datafuselabs/databend/pull/6995)
- 跟踪问题: [datafuselabs/databend#6994](https://github.com/datafuselabs/databend/issues/6994)

## 摘要

本 RFC 描述了 JSON 性能优化的设计。

## 动机

目前，Databend 半结构化数据以原始文本 JSON 格式存储，并使用 `serde_json` 进行序列化和反序列化。
它存在以下性能问题：

1. 每次使用 JSON 时都必须进行解析，文本解析非常慢，尤其是对于大型复杂对象数据。
2. 查询单个键路径需要读取和解析整个 JSON 数据，这会占用更多的解析时间和内存。

为了使半结构化数据的查询性能与其他数据类型一样快。本 RFC 提出了以下两个提议：

- 自动检测 JSON 列中频繁查询的键路径，并将它们提取为虚拟列，以实现与其他列类似的查询性能。
- 使用 JSONB 而不是 JSON 作为半结构化数据类型的底层二进制编码格式，这将优化解析速度并有利于键路径访问。

## 指南级说明

无。

## 参考级说明

### 虚拟列

JSON 的模式可以任意更改。然而，在实际使用中，JSON 数据通常由机器生成，并具有相当严格和可预测的结构。
利用这一特点，我们可以检测并提取 JSON 的频繁查询键路径作为虚拟列，以加速查询处理。

#### 收集频繁访问的 JSON 键路径

提取和存储虚拟列需要额外的解析过程和存储资源，因此为所有键路径生成虚拟列是不合适的。
我们应该只为频繁查询的 JSON 键路径生成虚拟列。

为了知道哪些键路径被频繁查询，
我们使用 [FPGrowth 算法](https://www.cs.sfu.ca/~jpei/publications/sigmod00.pdf) 来计算 JSON 数据键路径的访问频率。
“FP”代表频繁模式，通常用于计算项目频率和识别频繁项。
每次用户查询 JSON 数据的一个键路径时，都会被 FPGrowth 算法记录下来，最终生成一棵树状的统计信息。
我们可以使用这个统计信息来确定哪些键路径需要生成虚拟列。

#### 提取虚拟列

提取虚拟列的操作是异步进行的，因此不会影响数据插入的性能。
由于 Databend 会定期压缩表块，我们可以将提取虚拟列作为额外操作进行，如果列数据类型是 JSON。
这样，已经读取用于压缩的数据可以被重用，这将减少不必要的读放大。

提取虚拟列的过程如下：

1. 收集访问计数超过 FPGrowth 算法生成的阈值的键路径。
2. 解析 JSON 数据，推断所有键路径的 JSON 模式，包括值的数据类型和行号。
3. 检查所有键路径，如果值的数据类型相同，并且每行都有数据，从这个键路径提取数据生成虚拟列，并将它们存储在单独的 parquet 文件中。

以以下 JSON 为例。

```json
{"id":1,"title":"a","user":{"id":1,"name":"a"},"tags":["t1","t2"]}
{"id":2,"title":"b","user":{"id":2,"name":"b"},"tags":["t3","t4"]}
{"id":3,"title":"c","user":{"id":3,"name":3}}
{"id":4,"title":"d","user":{"id":4,"name":4}}
```

键路径 `id`、`title` 和 `user:id` 具有相同的数据类型，我们可以将它们提取为虚拟列。
对于 `user.name`，数据类型的值不同。
对于 `tags`，它不在每一行上。我们不为它们生成虚拟列。

#### 将键路径访问下推到存储

访问 json 键路径有两种方式：点表示法，如 `col:level1:level2` 和括号表示法，如 `col['level1'][0]`。

例如：

```sql
create table test (id int8, v json);
insert into test values(1, parse_json('{"k1":{"k2":"v"},"a":[0,1,2]}'));
select v:k1:k2, v['a'][0] from test;
+---------+-----------+
| v:k1:k2 | v['a'][0] |
+---------+-----------+
| "v"     | 0         |
+---------+-----------+
```

目前，JSON 键路径的访问将被转换为 `get` 标量函数，并通过键遍历 JSON 以获取值。
为了使用虚拟列提高性能，我们需要修改查询计划并将键路径访问下推到存储层。
由于我们使用 JSONB 而不是 JSON，即使对于没有生成虚拟列的键路径，下推到存储层也会带来好处。

### JSONB

JSONB 代表 `JSON Binary` 或 `JSON better`，这是 PostgreSQL 从 v9.4 开始支持的一种优化的二进制格式数据类型。
CockroachDB 也基于 PostgreSQL 设计实现了 JSONB。

通过将数据存储为 JSONB 而不是 JSON，我们可以获得以下好处：

- JSONB 的解析和查询过程明显更快。
- 访问特定键路径不需要读取完整数据，这将大大提高整体性能。
- 可以添加外部索引以进一步加速查询。

#### 二进制编码

JSONB 是一种树结构。每个节点由三部分组成，一个 32 位的头部，几个 32 位的 `JEntry`，以及可变长度的原始内容。

- 头部也称为容器头部，它包括一个 3 位的类型（包括 `array`、`object` 和 `scalar`）和一个 28 位的数字，用于指示 `array` 或 `object` 中的元素数量。
- `JEntry` 有一个 3 位的值类型（包括 `true`、`false`、`null`、`string`、`number`、`array` 和 `object`），一个 28 位提供原始内容的长度或偏移量，以及一个 1 位标志，用于指示使用长度还是偏移量。
- 最后一部分是原始内容值，可以通过 `JEntry` 中的长度或偏移量定位。

以此 JSON 为例，我们可以看到 JSONB 的编码格式如下。

```json
{"a":1,"b":[true,2,"v"]}
```

```
  .--------------.    .-----------------------------------.
  |    header    | -> |    type(object) | item nums(2)    |
  .--------------.    .-----------------------------------.
  | key1 JEntry  | -> | flag | val type(string) | len/off | -+
  .--------------.    .-----------------------------------.  |
  | key2 JEntry  | -> | flag | val type(string) | len/off | -+-+
  .--------------.    .-----------------------------------.  | |
  | val1 JEntry  | -> | flag | val type(number) | len/off | -+-+-+
  .--------------.    .-----------------------------------.  | | |
  | val2 JEntry  | -> | flag | val type(string) | len/off | -+-+-+-+
  .--------------.    .-----------------------------------.  | | | |
  |     "a"      | <-----------------------------------------+ | | |
  .--------------.                                             | | |
  |     "b"      | <-------------------------------------------+ | |
  .--------------.                                               | |
  |      1       | <---------------------------------------------+ |
  .--------------.                                                 |
  | [true,2,"v"] | <-----------------------------------------------+
  .--------------.
        |           .--------------+    .-----------------------------------.
        +---------> |    header    | -> |    type(array) | item nums(3)     |
                    .--------------+    .-----------------------------------.
                    | item1 JEntry | -> | flag | val type(bool true)        |
                    .--------------+    .-----------------------------------.
                    | item2 JEntry | -> | flag | val type(number) | len/off | -+
                    .--------------+    .-----------------------------------.  |
                    | item3 JEntry | -> | flag | val type(string) | len/off | -+-+
                    .--------------+    .-----------------------------------.  | |
                    |      2       | <-----------------------------------------+ |
                    .--------------.                                             |
                    |     "v"      | <-------------------------------------------+
                    .--------------.

有关更多详细信息，请参见 [PostgreSQL](https://github.com/postgres/postgres/blob/master/src/include/utils/jsonb.h)
和 [CockroachDB](https://github.com/cockroachdb/cockroach/blob/master/docs/RFCS/20171005_jsonb_encoding.md) 的设计

得益于 JSONB 的树状结构，搜索键路径只需要解析完整数据的一部分。
在每个节点中，对象键可以在 O(𝑙𝑜𝑔(𝑛)) 时间内被访问，因为键是排序的并且可以使用二分查找，而数组元素可以在 O(1) 时间内被访问，因为 JEntry 的长度是固定的。

## 缺点

- 提取虚拟列需要额外的异步任务。
- JSONB 可能会占用比 JSON 更多的磁盘空间。

## 原理和替代方案

[BSON](http://bsonspec.org) 是 MongoDB 使用的一种二进制 JSON 格式。
其主要设计目标是存储文档，因此它在头部没有键路径的索引。

[ION](https://amzn.github.io/ion-docs/) 也是由亚马逊开发的一种二进制 JSON 格式。
它针对读取进行了优化，并且有符号表作为索引以加速键路径访问。
其主要问题是 Rust 版本的开发仍处于早期阶段，缺乏一些重要的特性支持，如 `serde`。

还有一些针对纯文本 json 的优化，例如
[simd-json](https://github.com/simd-lite/simd-json) 使用 SIMD 指令加速解析，
[Pison](https://github.com/AutomataLab/Pison) 通过添加位图索引加速解析。
但它们针对的是全数据解析优化，这并不有助于通过键路径加速访问。

## 先行技术

这个 RFC 的主要思想来自于 [JSON Tiles](https://db.in.tum.de/people/sites/durner/papers/json-tiles-sigmod21.pdf) 论文。
论文中的实验评估显示，这些优化可以有效地提高 JSON 数据的读取性能。

PostgreSQL 和 CockroachDB 使用 JSONB 作为优化后的 JSON 格式，我们可以基于它们的设计实现 Rust 版本的 JSONB。

## 未解决的问题

无。

## 未来可能性

- 为具有不同数据类型值的键路径提取虚拟列
- 为 JSONB 添加额外索引
```