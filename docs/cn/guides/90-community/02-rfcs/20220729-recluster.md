```markdown
---
title: 重新聚类表
description: 
  重新聚类聚类表的RFC
---

## 摘要

聚类的灵感来源于Snowflake中的数据聚类和Oracle中的属性聚类。

聚类表根据表中某一组列的值以有序的方式存储数据。聚类对于分区消除和文件碎片整理有益。

默认情况下，数据根据自然维度存储在表中。我们需要通过聚类键重新聚类表。另一方面，即使聚类表已经很好地聚类，如果不断写入新数据，聚类随时间推移会变得更糟。因此，需要添加重新聚类操作。

## 设计

有关更详细的原理和图片，请参考 [snowflake自动聚类](https://sundy-li.github.io/posts/探索snowflake-auto-clustering/)。

执行全表排序的成本非常昂贵，尤其是对于不断有新数据流入的表。为了在高效剪枝和低成本之间取得平衡，表只需要被大致排序而不是完全排序。因此，在[指标](#metrics)中引入了两个指标来确定表是否聚类良好。重新聚类的目标是减少`overlap`和`depth`。

为了避免多次在同一数据片段上翻动，我们像LSM树一样将块分成不同的级别。重新聚类类似于LSM压缩操作。`level`表示该块中的数据已被聚类的次数。重新聚类操作在相同级别上执行。

```rust
pub struct ClusterStatistics {
    ... ...
    pub level: i32,
}
```

重新聚类操作的工作流程分为两个任务，块选择和块合并。

### 语法

```sql
alter table [if exists] tbl_name recluster [final] [where condition]
```

如果指定`final`，则进行优化，直到表足够好地聚类为止。否则，重新聚类工作流只运行一次。

该语句应由表上的DML触发。

### 指标

- overlap
  与给定块重叠的块数。

- depth
  在同一点重叠的块数。这些点是从聚类值域范围的最小值和最大值中收集的。

### 块选择

新进数据的初始级别为0。我们首先关注较新的数据，换句话说，选择操作优先在级别0上执行。这样做的优势是减少写放大。

1. 计算每个点的深度和块的重叠，并汇总以获得avg_depth。该算法已在[system$clustering_information](https://github.com/datafuselabs/databend/pull/5426)中反映，不再重复。avg_depth的理想结果是1。为了实现大致排序，考虑定义一个阈值或比例（threshold = blocks_num * ratio）。只要avg_depth不大于此阈值，该级别的块可以被认为是良好聚类的，然后我们在下一个级别上执行块选择。

2. 选择具有最高深度的点范围（一个或多个），并选择该范围覆盖的块作为下一个块合并的对象集。如果有多个范围具有最高深度，则在块合并期间可能有多个块集可以并行化。

提示：
```
1. 聚类键可能在表中有数据时创建或更改，因此可能有些块不是按聚类键排序的。考虑在进行重新聚类时暂时忽略这样的块。

2. 如果块的聚类键只有一个值（最大值和最小值相等，达到常数状态）且其row_num为1_000_000，将其级别设置为-1，并在进行重新聚类时过滤掉。

3. 选定的块可能需要考虑总大小，否则排序可能会内存溢出。
```

### 块合并

对收集的块进行排序和合并。合并后的块超过一定阈值（1_000_000行）时，将被分割成多个块。新生成的块放入下一个级别。

组织块并生成新的段和快照，最后更新表元数据。如果在此期间有新的DML执行，当前工作流将失败提交并返回错误。我们需要考虑稍后的具体处理流程。

选择和合并操作重复进行，直到表足够好地聚类为止。
```